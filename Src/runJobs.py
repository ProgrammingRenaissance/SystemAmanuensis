"""
Ubuntu Installation Configuration Script.

This script runs the configuration process for a new installtion of Ubuntu.
The script does nothing but invoke the  the worker scripts. There is one
worker script for each step in the configuration process.
This script manages the entire environment for the installation process.
It is intended that the worker scripts shall be independent of each other
and should not be affeccted by the operation of another script.
This independence allows parallelism which will help to shorten the
installation process. The one permitted dependency is that later scripts
may depend on the work product produced by earlier scripts. Thus we need
some form of dependency management which will be supplied by this script.
The names of the worker scripts to be run and their dependencies will be
stored in a JSON configuration file which will be loaded at initialization
time.

This script can either run in an independent manner, being invoked directly
from the command line, or it may be invoked from another script. In this
case, the main() function where the work is controlled must be invoked by
the caller after constructing an instance object of InstallationConfigurator,

This script is designed to handle any installation environment that can be
generated by the underlying Ubuntu facilities. This means that copies of new
installations can be created and connfigured offline before being installed.
The system makes use of the chroot capability of Ubuntu to implement this
support.

As will be seen later, this package actually allows multiple installation
environments to be handled in parallel. This can happen because all the
information needed to configure a particular installation is held in a
configuration file and the application accepts as many scripts as you like
for a particular invocation.
Depending on available resources, it then attempts to run as many installation
configurations as possible. The initial implementation will be simplistic
and will only honor prerequisites between configuration steps.
"""

import argparse
from pathlib import Path
import sys
from tempfile import TemporaryDirectory
from typing import Any, Union, List
from typing_extensions import LiteralString
sys.path.insert(0, "/mnt/PR/Library/Src")

import Cmd  # noqa: E402


class RunJobs(object):
    """Ubuntu Installation Configuration."""

    # Keywords expected in Keyword arguments
    kTesting: LiteralString = "Testing"

    # Keywords expected in final connfiguration
    kJobs: LiteralString = 'Jobs'

    def __init__(self,
                 *args: Union[Path, str],
                 **kwargs: dict[str, Any]) -> None:
        """
        Build some configurators.

        Arguments:
            args:   A tuple containing a mixture of command line options
                    and zero or more paths to JSON datasets that contain steps
                    in a multi-step procedure.
            kwargs: A dictionary containing keyword arguments.
        """

        def getArgs(*args: Union[Path, str],
                    kwargs: dict[str, Any]) -> dict[str, Any]:
            """
            Parse command line arguments.

            Arguments: The same as for __init__
            """
            # First separate JSON paths from command line args in the
            # positional argument list. Json file paths will not be
            # handled as arguments. The command line arguments will be
            # added to sys.path and will be handled during argument parsing.
            t = type(args[i])  # type: ignore
            jobs: List[Path] = []
            jobSteps: dict[str, Any] = {}
            for i in range(len(args)):
                if t == Path:
                    jobs.append(args[i])  # type: ignore
                elif t == str:
                    sys.path.insert(0, args[i])  # type: ignore
                else:
                    raise TypeError(
                     f"Argument {args[i]} has type {t}. Should be Path or str")

                parser:argparse.ArgumentParser = \
                    argparse.ArgumentParser(prog='runJobs',
                                            description=__doc__)
            jobSteps[RunJobs.kJobs] = jobs
            return jobSteps

        self.tempStorageDir: TemporaryDirectory[str] =\
            TemporaryDirectory(ignore_cleanup_errors=True)
        self.testing: bool =\
            kwargs.get(RunJobs.kTesting, False)  # type: ignore

    def main(self) -> None:
        """Do installation configuration process."""
        with self.tempStorageDir as tmpdn:  # type: ignore
            for job in self.jobs:
                if job:
                    pass  # We have a job to process


if __name__ == "__main__":
    # Run the job management process if we are running standalone
    RunJobs().main()

sys.exit(0)  # Normal exit from module
